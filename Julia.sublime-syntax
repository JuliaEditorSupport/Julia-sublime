%YAML 1.2
---
# https://www.sublimetext.com/docs/3/syntax.html
name: Julia
file_extensions: [jl]
first_line_match: ^#!.*\bjulia\s*$
scope: source.julia

variables:
  symb_op_ascii: '[-+*/\\=^:.<>~?&$%|]'

  # The list of unicode symbols allowed as operators is fetched from the Julia parser https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm
  symb_op_unicode: '[≤≥¬←→↔↚↛↠↣↦↮⇎⇏⇒⇔⇴⇶⇷⇸⇹⇺⇻⇼⇽⇾⇿⟵⟶⟷⟷⟹⟺⟻⟼⟽⟾⟿⤀⤁⤂⤃⤄⤅⤆⤇⤌⤍⤎⤏⤐⤑⤔⤕⤖⤗⤘⤝⤞⤟⤠⥄⥅⥆⥇⥈⥊⥋⥎⥐⥒⥓⥖⥗⥚⥛⥞⥟⥢⥤⥦⥧⥨⥩⥪⥫⥬⥭⥰⧴⬱⬰⬲⬳⬴⬵⬶⬷⬸⬹⬺⬻⬼⬽⬾⬿⭀⭁⭂⭃⭄⭇⭈⭉⭊⭋⭌￩￫≡≠≢∈∉∋∌⊆⊈⊂⊄⊊∝∊∍∥∦∷∺∻∽∾≁≃≄≅≆≇≈≉≊≋≌≍≎≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≣≦≧≨≩≪≫≬≭≮≯≰≱≲≳≴≵≶≷≸≹≺≻≼≽≾≿⊀⊁⊃⊅⊇⊉⊋⊏⊐⊑⊒⊜⊩⊬⊮⊰⊱⊲⊳⊴⊵⊶⊷⋍⋐⋑⋕⋖⋗⋘⋙⋚⋛⋜⋝⋞⋟⋠⋡⋢⋣⋤⋥⋦⋧⋨⋩⋪⋫⋬⋭⋲⋳⋴⋵⋶⋷⋸⋹⋺⋻⋼⋽⋾⋿⟈⟉⟒⦷⧀⧁⧡⧣⧤⧥⩦⩧⩪⩫⩬⩭⩮⩯⩰⩱⩲⩳⩴⩵⩶⩷⩸⩹⩺⩻⩼⩽⩾⩿⪀⪁⪂⪃⪄⪅⪆⪇⪈⪉⪊⪋⪌⪍⪎⪏⪐⪑⪒⪓⪔⪕⪖⪗⪘⪙⪚⪛⪜⪝⪞⪟⪠⪡⪢⪣⪤⪥⪦⪧⪨⪩⪪⪫⪬⪭⪮⪯⪰⪱⪲⪳⪴⪵⪶⪷⪸⪹⪺⪻⪼⪽⪾⪿⫀⫁⫂⫃⫄⫅⫆⫇⫈⫉⫊⫋⫌⫍⫎⫏⫐⫑⫒⫓⫔⫕⫖⫗⫘⫙⫷⫸⫹⫺⊢⊣⊕⊖⊞⊟∪∨⊔±∓∔∸≂≏⊎⊻⊽⋎⋓⧺⧻⨈⨢⨣⨤⨥⨦⨧⨨⨩⨪⨫⨬⨭⨮⨹⨺⩁⩂⩅⩊⩌⩏⩐⩒⩔⩖⩗⩛⩝⩡⩢⩣÷⋅∘×∩∧⊗⊘⊙⊚⊛⊠⊡⊓∗∙∤⅋≀⊼⋄⋆⋇⋉⋊⋋⋌⋏⋒⟑⦸⦼⦾⦿⧶⧷⨇⨰⨱⨲⨳⨴⨵⨶⨷⨸⨻⨼⨽⩀⩃⩄⩋⩍⩎⩑⩓⩕⩘⩚⩜⩞⩟⩠⫛⊍▷⨝⟕⟖⟗↑↓⇵⟰⟱⤈⤉⤊⤋⤒⤓⥉⥌⥍⥏⥑⥔⥕⥘⥙⥜⥝⥠⥡⥣⥥⥮⥯￪￬]'
  symb_op: '(?:{{symb_op_ascii}}|{{symb_op_unicode}})'

  # Multi-character operators
  long_op: (?:\+=|-=|\*=|/=|//=|\\\\=|^=|÷=|%=|<<=|>>=|>>>=|\|=|&=|:=|=>|$=|\|\||<:|>:|\|>|<\||//|\+\+)

  # Built-in types. This list is generated with unique(filter(x -> isa(x, DataType), map(eval, [names(Base); names(Core)]))) and some filtering. Manually added Vector and Matrix
  base_types: \b(Pair|AbstractChannel|AbstractRNG|AbstractSerializer|AbstractSparseArray|AbstractUnitRange|ArgumentError|Array|AssertionError|Associative|Base64DecodePipe|Base64EncodePipe|Bidiagonal|BigFloat|BigInt|BitArray|BufferStream|CachingPool|CapturedException|CartesianIndex|CartesianRange|Int8|Float64|Float32|Channel|Int32|Int64|ClusterManager|Cmd|Colon|Complex|CompositeException|Condition|Int16|UInt64|Cstring|UInt8|UInt32|UInt16|Cwstring|Date|DateTime|Diagonal|Dict|DimensionMismatch|Display|EOFError|EachLine|Enum|Enumerate|ErrorException|Factorization|FileMonitor|Filter|FloatRange|Future|HTML|Hermitian|Base.AbstractIOBuffer|IOContext|IOStream|IPAddr|IPv4|IPv6|InitError|IntSet|InvalidStateException|Irrational|KeyError|LinSpace|LoadError|LowerTriangular|MIME|MersenneTwister|MethodError|NullException|Nullable|ObjectIdDict|OrdinalRange|ParseError|PartialQuickSort|Pipe|PollingFileWatcher|ProcessExitedException|RandomDevice|Range|Rational|RawFD|ReentrantLock|Regex|RegexMatch|RemoteChannel|RemoteException|RepString|RevString|RoundingMode|SerializationState|Set|SharedArray|SparseMatrixCSC|SparseVector|StackFrame|StepRange|String|SubArray|SubString|SymTridiagonal|Symmetric|SystemError|TCPSocket|Text|TextDisplay|Timer|Tridiagonal|TypeError|UDPSocket|UnicodeError|UniformScaling|UnitRange|UpperTriangular|Val|VersionNumber|WeakKeyDict|WorkerConfig|WorkerPool|Zip|AbstractArray|AbstractFloat|AbstractString|Any|Bool|BoundsError|Char|DataType|DenseArray|DirectIndexString|DivideError|DomainError|Exception|Expr|Float16|Function|GlobalRef|GotoNode|IO|InexactError|Int128|Integer|InterruptException|LabelNode|LambdaInfo|LineNumberNode|Method|MethodTable|Module|NewvarNode|Number|OutOfMemoryError|OverflowError|Ptr|QuoteNode|ReadOnlyMemoryError|Real|Ref|SSAValue|SegmentationFault|Signed|SimpleVector|Slot|SlotNumber|StackOverflowError|Symbol|Task|Tuple|Type|TypeConstructor|TypeMapEntry|TypeMapLevel|TypeName|TypeVar|TypedSlot|UInt128|UndefRefError|UndefVarError|Union|Unsigned|Vararg|VecElement|Void|WeakRef|Vector|Matrix)\b

  # Built-in functions. This list is generated with join(filter!(x -> isascii(x[1]) && isalpha(x[1]) && islower(x[1]), map(string, names(Base))), '|')
  base_funcs: \b(abs|abs2|abspath|accept|acos|acosd|acosh|acot|acotd|acoth|acsc|acscd|acsch|addprocs|airy|airyai|airyaiprime|airybi|airybiprime|airyprime|airyx|all|all!|allunique|angle|any|any!|append!|apropos|ascii|asec|asecd|asech|asin|asind|asinh|assert|asyncmap|atan|atan2|atand|atanh|atexit|atreplinit|backtrace|base|base64decode|base64encode|basename|besselh|besselhx|besseli|besselix|besselj|besselj0|besselj1|besseljx|besselk|besselkx|bessely|bessely0|bessely1|besselyx|beta|bfft|bfft!|big|bin|bind|binomial|bitbroadcast|bitpack|bitrand|bits|bitunpack|bkfact|bkfact!|blas_set_num_threads|blkdiag|brfft|broadcast|broadcast!|broadcast!_function|broadcast_function|broadcast_getindex|broadcast_setindex!|bswap|bytes2hex|bytestring|call|cat|catalan|catch_backtrace|catch_stacktrace|cbrt|cd|ceil|cell|cfunction|cglobal|charwidth|checkbounds|checkindex|chmod|chol|cholfact|cholfact!|chomp|chop|chown|chr2ind|circshift|cis|clamp|clamp!|cld|clear!|clipboard|close|cmp|code_llvm|code_lowered|code_native|code_typed|code_warntype|collect|colon|combinations|complex|cond|condskeel|conj|conj!|connect|consume|contains|conv|conv2|convert|copy|copy!|copysign|cor|cos|cosc|cosd|cosh|cospi|cot|cotd|coth|count|count_ones|count_zeros|countfrom|countlines|countnz|cov|cp|cross|csc|cscd|csch|ctime|ctranspose|ctranspose!|cummax|cummin|cumprod|cumprod!|cumsum|cumsum!|cumsum_kbn|current_module|current_task|cycle|dawson|dct|dct!|dec|deconv|deepcopy|default_worker_pool|deg2rad|delete!|deleteat!|den|deserialize|det|detach|diag|diagind|diagm|diff|digamma|digits|digits!|dirname|disable_sigint|display|displayable|displaysize|div|divrem|done|dot|download|drop|dropzeros|dropzeros!|dump|e|eachindex|eachline|eachmatch|edit|eig|eigfact|eigfact!|eigmax|eigmin|eigs|eigvals|eigvals!|eigvecs|eltype|empty!|endof|endswith|enumerate|eof|eps|erf|erfc|erfcinv|erfcx|erfi|erfinv|error|esc|escape_string|eta|etree|eu|eulergamma|evalfile|exit|exp|exp10|exp2|expand|expanduser|expm|expm1|exponent|extrema|eye|factor|factorial|factorize|falses|fd|fdio|fetch|fft|fft!|fftshift|field_offset|fieldname|fieldnames|fieldoffset|fieldoffsets|filemode|filesize|fill|fill!|filt|filt!|filter|filter!|finalize|finalizer|find|findfirst|findin|findlast|findmax|findmax!|findmin|findmin!|findn|findnext|findnz|findprev|first|fld|fld1|fldmod|fldmod1|flipbits!|flipdim|flipsign|float|floor|flush|fma|foldl|foldr|foreach|frexp|full|fullname|functionloc|gamma|gc|gc_enable|gcd|gcdx|gensym|get|get!|get_bigfloat_precision|get_rounding|get_zero_subnormals|getaddrinfo|gethostname|getindex|getipaddr|getkey|getpid|getsockname|givens|golden|gperm|gradient|graphemes|hankelh1|hankelh1x|hankelh2|hankelh2x|hash|haskey|hcat|hessfact|hessfact!|hex|hex2bytes|hex2num|hist|hist!|hist2d|hist2d!|histrange|homedir|htol|hton|hvcat|hypot|idct|idct!|identity|ifelse|ifft|ifft!|ifftshift|ignorestatus|im|imag|in|include|include_dependency|include_string|ind2chr|ind2sub|indexin|indexpids|indices|indmax|indmin|info|init_worker|insert!|instances|interrupt|intersect|intersect!|inv|invdigamma|invmod|invperm|ipermute!|ipermutedims|irfft|is_apple|is_assigned_char|is_bsd|is_linux|is_unix|is_windows|isabspath|isalnum|isalpha|isapprox|isascii|isassigned|isbits|isblockdev|ischardev|iscntrl|isconst|isdiag|isdigit|isdir|isdirpath|isempty|isequal|iseven|isexecutable|isfifo|isfile|isfinite|isgeneric|isgraph|ishermitian|isimag|isimmutable|isinf|isinteger|isinteractive|isleaftype|isless|islink|islocked|islower|ismarked|ismatch|ismount|isnan|isnull|isnumber|isodd|isopen|ispath|isperm|isposdef|isposdef!|ispow2|isprime|isprint|ispunct|isqrt|isreadable|isreadonly|isready|isreal|issetgid|issetuid|issocket|issorted|isspace|issparse|issticky|issubnormal|issubset|issym|issymmetric|istaskdone|istaskstarted|istext|istextmime|istril|istriu|isupper|isvalid|iswritable|isxdigit|join|joinpath|keys|keytype|kill|kron|last|launch|lbeta|lcfirst|lcm|ldexp|ldltfact|ldltfact!|leading_ones|leading_zeros|length|less|levicivita|lexcmp|lexless|lfact|lgamma|linearindices|linreg|linspace|listen|listenany|localindexes|lock|log|log10|log1p|log2|logabsdet|logdet|logm|logspace|lowercase|lpad|lq|lqfact|lqfact!|lstat|lstrip|ltoh|lu|lufact|lufact!|lyap|macroexpand|manage|map|map!|mapfoldl|mapfoldr|mapreduce|mapreducedim|mapslices|mark|match|matchall|max|maxabs|maxabs!|maximum|maximum!|maxintfloat|mean|mean!|median|median!|merge|merge!|method_exists|methods|methodswith|middle|midpoints|mimewritable|min|minabs|minabs!|minimum|minimum!|minmax|mkdir|mkpath|mktemp|mktempdir|mod|mod1|mod2pi|modf|module_name|module_parent|mtime|muladd|mv|myid|names|nb_available|ndigits|ndims|next|nextfloat|nextind|nextpow|nextpow2|nextprod|nnz|nonzeros|norm|normalize|normalize!|normalize_string|normpath|notify|now|nprocs|nthperm|nthperm!|ntoh|ntuple|nullspace|num|num2hex|nworkers|nzrange|object_id|oct|oftype|one|ones|open|operm|ordschur|ordschur!|parent|parentindexes|parity|parse|parseip|partitions|peakflops|permutations|permute|permute!|permutedims|permutedims!|pi|pinv|pipeline|plan_bfft|plan_bfft!|plan_brfft|plan_dct|plan_dct!|plan_fft|plan_fft!|plan_idct|plan_idct!|plan_ifft|plan_ifft!|plan_irfft|plan_rfft|pmap|pointer|pointer_from_objref|pointer_to_array|pointer_to_string|poll_fd|poll_file|polygamma|pop!|popdisplay|position|powermod|precision|precompile|prepend!|prevfloat|prevind|prevpow|prevpow2|prevprod|primes|primesmask|print|print_escaped|print_joined|print_shortest|print_unescaped|print_with_color|println|process_exited|process_running|procs|prod|prod!|produce|promote|promote_rule|promote_shape|promote_type|push!|pushdisplay|put!|pwd|qr|qrfact|qrfact!|quadgk|quantile|quantile!|quit|rad2deg|rand|rand!|randcycle|randexp|randexp!|randjump|randn|randn!|randperm|randstring|randsubseq|randsubseq!|range|rank|rationalize|read|read!|readall|readandwrite|readavailable|readbytes|readbytes!|readchomp|readcsv|readdir|readdlm|readline|readlines|readlink|readstring|readuntil|real|realmax|realmin|realpath|recv|recvfrom|redirect_stderr|redirect_stdin|redirect_stdout|redisplay|reduce|reducedim|reenable_sigint|reim|reinterpret|reload|relpath|rem|rem1|remote|remotecall|remotecall_fetch|remotecall_wait|repeat|repeated|replace|repmat|repr|reprmime|reset|reshape|resize!|rest|rethrow|retry|reverse|reverse!|reverseind|rfft|rm|rmprocs|rol|rol!|ror|ror!|rot180|rotl90|rotr90|round|rounding|rowvals|rpad|rsearch|rsearchindex|rsplit|rstrip|run|scale|scale!|schedule|schur|schurfact|schurfact!|sdata|search|searchindex|searchsorted|searchsortedfirst|searchsortedlast|sec|secd|sech|seek|seekend|seekstart|select|select!|selectperm|selectperm!|send|serialize|set_bigfloat_precision|set_rounding|set_zero_subnormals|setdiff|setdiff!|setenv|setindex!|setprecision|setrounding|shift!|show|showall|showcompact|showcompact_lim|showerror|shuffle|shuffle!|sign|signbit|signed|signif|significand|similar|sin|sinc|sind|sinh|sinpi|size|sizehint!|sizeof|skip|skipchars|sleep|slice|slicedim|sort|sort!|sortcols|sortperm|sortperm!|sortrows|sparse|sparsevec|spawn|spdiagm|specialized_binary|specialized_bitwise_binary|specialized_bitwise_unary|specialized_unary|speye|splice!|split|splitdir|splitdrive|splitext|spones|sprand|sprandbool|sprandn|sprint|spzeros|sqrt|sqrtm|squeeze|srand|stacktrace|start|startswith|stat|std|stdm|step|stride|strides|string|stringmime|strip|strwidth|sub|sub2ind|subtypes|success|sum|sum!|sum_kbn|sumabs|sumabs!|sumabs2|sumabs2!|summary|super|supertype|svd|svdfact|svdfact!|svds|svdvals|svdvals!|sylvester|symbol|symdiff|symdiff!|symlink|symperm|systemerror|take|take!|takebuf_array|takebuf_string|tan|tand|tanh|task_local_storage|tempdir|tempname|tic|time|time_ns|timedwait|toc|toq|touch|trace|trailing_ones|trailing_zeros|trailingsize|transcode|transpose|transpose!|trigamma|tril|tril!|triu|triu!|trues|trunc|truncate|trylock|tryparse|typeintersect|typejoin|typemax|typemin|ucfirst|unescape_string|union|union!|unique|unlock|unmark|unsafe_copy!|unsafe_load|unsafe_pointer_to_objref|unsafe_read|unsafe_store!|unsafe_string|unsafe_trunc|unsafe_wrap|unsafe_write|unshift!|unsigned|uperm|uppercase|utf8|valtype|values|var|varm|vcat|vec|vecdot|vecnorm|versioninfo|view|wait|walkdir|warn|watch_file|which|whos|widemul|widen|with_bigfloat_precision|with_rounding|withenv|workers|workspace|write|writecsv|writedlm|xcorr|xdump|yield|yieldto|zero|zeros|zeta|zip)\b

  # Symbols part of the language syntax
  symb_lang: (?:[(){}\[\],.;:'"`@#])

  # General identifier symbol
  symb_id: (?:[^\s{{symb_lang}}{{symb_op}}])

  # Alternative to \b that works with unicode symbols
  b: (?<=(?:^|\s|{{symb_lang}}|{{symb_op}}))

  # Recursively match nested curly braces
  # Must be wrapped in a matching group when used. It is best to do this explicitly when used (not here) to avoid confusion.
  # This regex depends on atomic group and back reference recursion.
  # Cannot match multi-line types, because sublime applies regexes line by line.
  # TODO: Parse multi-line types separately with push/pop matching. Omg pls no! {nested_braces} is used in 10 places and push/pop would make the code very messy. Who uses multi-line types anyway?
  nested_braces: '{(?>[^{}]+|\g<-1>)*}'

  # Recursively match nested brackets (of any type) and strings
  # Must be wrapped in a matching group when used. It is best to do this explicitly when used (not here) to avoid confusion.
  # NOTE: Use of atomic groups speeds up parsing immensely.
  string: '"(?>(?>\\"|[^"])*|\g<-1>)*"'
  nested_brackets_and_strings: |-
    (?x)
    (?>
       {(?>{{string}}|[^{}]+|\g<-1>)*}|
      \((?>{{string}}|[^()]+|\g<-1>)*\)|
      \[(?>{{string}}|[^\[\]]+|\g<-1>)*\]|
      {{string}}
    )

  # Helpers for function declaration
  func_name_standard: |-
    (?x)
    (?!!)                     # Function name doesn't start with !
    ([^\s{{symb_lang}}]+)     # Function name
    ({{nested_braces}})?      # Match type annotation
    (?=[\( ])
  func_name_paren: |-
    (?x)
    \(                        # Function name is wrapped in parentheses
    (?!!)                     # Function name doesn't start with !
    (::)?                     # Function name can start with ::
    ((?:                      # Rest of function name
      ({{nested_braces}})|    # Match nested brackets
      [^)]                    # or anything that doesn't close paren
    )+)
    \)
    ({{nested_braces}})?      # Match type annotation
    (?=\()
  func_params: |-
    (?x)
    \(                        # Open function parameters
    # We are lazy here and don't parse the exact form of a parameter list
    # with types, default values, splats etc. It is not needed.
    (
      ({{nested_brackets_and_strings}})| # Match nested brackets, can occur in parameter default value etc.
      [^(){}\[\]"]            # or anything that doesn't close the argument list
    )*
    \)                        # Close function parameters
    \s*=(?!=)                 # Followed by exactly one equal sign

contexts:
  main:
    - include: declarations
    - include: expressions

  expressions:
    - include: comments
    - include: symbols
    - include: type-annotation
    - include: literals
    - include: operators
    - include: strings
    - include: keywords
    - include: macros
    - include: function-call
    - include: variable
    - include: nested_parens
    - include: nested_squarebrackets

  declarations:
    - include: decl-func
    - include: decl-func-assignment-form
    - include: decl-type
    - include: decl-macro
    - include: decl-typealias

  comments:
    - match: '#='
      push: comment-block
    - match: '#.*'
      scope: comment.line.number-sign.julia

  comment-block:
    - meta_scope: comment.block.number-sign-equals.julia
    - match: '#='
      push: comment-block
    - match: '=#'
      pop: true

  keywords:
    - match: \b(begin|end|function|type|macro|quote|let|local|global|const|abstract|typealias|bitstype|immutable|module|baremodule|using|import|export|importall|in)\b
      scope: keyword.other.julia
    - match: \b(if|else|elseif|for|while|do|try|catch|finally|return|break|continue)\b
      scope: keyword.control.julia

  operators:
    # - Bang is not only an operator symbol, it can also be
    #   part of a function name, thus it is treated separately.
    # - Single quote is not only an operator symbol, it can also start a string.
    #   It is an operator if it is preceded by an identifier, dot, single-quote right round bracket or right square bracket
    - match: ({{symb_op}}|!|(?<=(?:{{symb_id}}|[.')\]]))')
      scope: keyword.operator.julia

  function-call:
    - match: '(?=({{symb_id}}+)({{nested_braces}})?(\())'
      push:
        - meta_content_scope: meta.function-call.julia
        - match: '{{base_funcs}}'
          scope: variable.function.julia support.function.julia
        - match: '{{symb_id}}+'
          scope: variable.function.julia
        - match: '({{nested_braces}})'
          scope: support.type.julia
        - match: \(
          push:
          - meta_content_scope: meta.function-call.arguments.julia
          - include: expressions
          - match: (?=\))
            pop: true
        - match: \)
          scope: meta.function-call.julia
          pop: true

  literals:
    - match: |-
        (?x)
        (?: # Dashes betwen numeric symbols (11 = 1_1) are allowed everywhere.
          {{b}}0b[0-1](?:_?[0-1])*|             # binary
          {{b}}0o[0-7](?:_?[0-7])*|             # octal
          {{b}}0x[\da-fA-F](?:_?[\da-fA-F])*|   # hex
          {{b}}(?:
            \.\d(?:_?\d)*|                      # .11, .11
            \d(?:_?\d)*(?:\.(?:\d(?:_?\d)*)?)?| # 11.11, 11., 11
                                                # Empty match. Yes, this is intended, see the following line.
          )
          (?:e[-+]?\d(?:_?\d)*)?                # Any of the above followed by e+123 or similar, for scientific notation.
        )
      scope: constant.numeric.julia
    - match: \b(true|false|nothing|NaN|Inf)\b
      scope: constant.language.julia

  type-annotation:
    # Dollar is ok because types can be interpolated.
    # Dot is ok because types can be picked from modules,
    # but no more than one dot, because splat can follow type.
    - match: (::|<:)\s*((?:(?!\.\.)(?:[$.]|{{symb_id}}))+({{nested_braces}})?)
      captures:
        1: keyword.operator.julia
        2: support.type.julia

  decl-func:
    - match: '\b(?<!:)(function)\s+(?!@)'
      captures:
        1: keyword.other.julia
      push:
        - meta_scope: meta.function.julia
        - include: func-name-paren
        - include: func-name-standard
        # Anonymous function
        - match: \(
          set: function-parameters
        # Function name on the form "Module.func"
        - match: '([^.{(]+)(\.)'
          captures:
            1: variable.other.julia
            2: keyword.operator.julia

  # Do lookaheads to distinguish function calls from function definitions on assignment form
  decl-func-assignment-form:
    - match: |-
        (?x)
        (?=
          {{func_name_paren}}
          {{func_params}}
        )
      push: func-name-paren
    - match: |-
        (?x)
        (?=
          {{func_name_standard}}
          {{func_params}}
        )
      push: func-name-standard

  func-name-standard:
    - match: '{{func_name_standard}}'
      captures:
        1: entity.name.function.julia
        2: support.type.julia
      set: function-parameters

  func-name-paren:
    - match: '{{func_name_paren}}'
      captures:
        1: keyword.operator.julia
        2: entity.name.function.julia
        4: support.type.julia
      set: function-parameters

  function-parameters:
    - meta_content_scope: meta.function.parameters.julia
    - match: end
      scope: keyword.other
      pop: true
    - match: \)
      pop: true
    - include: comments
    - match: '='
      scope: keyword.operator.assignment.julia
      set:
        - meta_scope: meta.function.parameters.default-value.julia
        - match: '(?=[,;)])'
          set: function-parameters
        - include: expressions
    - include: type-annotation
    - match: \.\.\. # Splat after type
      scope: keyword.operator.julia
    - match: ({{symb_id}}+)(\.\.\.)?
      captures:
        1: variable.parameter.julia
        2: keyword.operator.julia

  decl-macro:
    - match: '\b(macro)\s+([^(]+)\('
      captures:
        1: keyword.other.julia
        2: entity.name.macro.julia
      set: function-parameters

  decl-type:
    - match: \b(type|immutable|abstract)\s+({{symb_id}}+)({{nested_braces}})?
      scope: meta.type.julia
      captures:
        1: keyword.other.julia
        2: entity.name.type.julia
        3: support.type.julia
    - match: \b(bitstype)\s+(\d+)\s+({{symb_id}}+({{nested_braces}})?)
      captures:
        1: keyword.other.julia
        2: constant.numeric.julia
        3: entity.name.type.julia

  decl-typealias:
    - match: \b(typealias)\s+({{symb_id}}+)({{nested_braces}})?\s+({{symb_id}}+({{nested_braces}})?)?
      captures:
        1: keyword.other.julia
        2: entity.name.type.julia
        3: entity.name.type.julia # Duplication because {{nested_braces}} must be wrapped in a matching group
        4: support.type.julia

  symbols:
    # This is slightly more involved than what one might first expect
    # because, for example, in `:aa` the symbol is `aa` but in `:+a` only `+` is the symbol.
    # Also take some extra steps to not mess up ternary a?b:c syntax.
    - match: |-
        (?x)
        (?<! {{symb_id}}: )   # Not preceded by `a:`
        (?<! {{symb_id}}\s: ) # or `a :` (How to match multiple spaces in lookbehind?)
        (?<! [<)}\].'"]: )    # or other symbol-blocking chars.
        (?<=:)                # Preceeded by colon.
        (                     # The actual symbol can be a
          (\.?{{long_op}})|   # (dotted) multi-character-operator
          (\.?{{symb_op}})|   # (dotted) operator
          @?{{symb_id}}*      # variable (or macro) name
        )
      scope: constant.other.symbol.julia

  macros:
    - match: '@{{symb_id}}+\b'
      # Julians want their macros to light up as functions by default
      # The scope `variable.macro` is applied last to give it precedence
      # so that user can override the color in the color theme.
      scope: support.function.julia variable.macro.julia

  variable:
    - match: '{{symb_id}}+({{nested_braces}})'
      scope: support.type.julia variable.type
    - match: '{{base_types}}'
      scope: support.type.julia variable.type
    - match: '{{symb_id}}+'
      scope: variable.other

  strings:
    # Regex string, tripple-quoted. Has special escaping and no string interpolation.
    - match: '\br"""'
      push:
      - meta_scope: string.quoted.other.julia
      - match: (\\"|\\\\)
        scope: constant.character.escape.julia
      - match: '"""'
        pop: true
    # Regex string. Has special escaping and no string interpolation.
    - match: '\br"'
      push:
      - meta_scope: string.quoted.other.julia
      - match: (\\"|\\\\)
        scope: constant.character.escape.julia
      - match: '"'
        pop: true
    # Triple double-quoted string
    - match: '"""'
      push: string-triple-content
    # Double-quoted
    - match: '"'
      push: string-standard-content
    # Prefixed double-quoted
    - match: '{{symb_id}}+"'
      push:
      - meta_scope: string.quoted.other.julia
      - include: string-escape
      - match: '"'
        pop: true
    # Single-quoted string
    - match: "'"
      push:
      - meta_scope: string.quoted.single.julia
      - include: string-escape
      - match: "'"
        pop: true
    # Cmd string
    - match: '`'
      push: string-cmd-content

  string-escape:
    - match: \\(\\|[0-3]\d{0,2}|[4-7]\d?|x[a-fA-F0-9]{0,2}|u[a-fA-F0-9]{0,4}|U[a-fA-F0-9]{0,8}|.)
      scope: constant.character.escape.julia

  string-standard-content:
    - meta_scope: string.quoted.double.julia
    - match: '"'
      pop: true
    - include: string-escape
    - match: \$
      scope: keyword.operator.julia
      set: string-standard-interpolation

  string-standard-interpolation:
    - match: (?<=\))
      set: string-standard-content
    - include: nested_parens
    - match: '{{symb_id}}+'
      scope: variable.other.julia
      set:
        - match: ''
          set: string-standard-content

  string-triple-content:
    - meta_scope: string.quoted.double.julia
    - match: '"""'
      pop: true
    - include: string-escape
    - match: \$
      scope: keyword.operator.julia
      set: string-triple-interpolation

  string-triple-interpolation:
    - match: (?<=\))
      set: string-triple-content
    - include: nested_parens
    - match: '{{symb_id}}+'
      scope: variable.other.julia
      set:
        - match: ''
          set: string-triple-content

  string-cmd-content:
    - meta_scope: string.quoted.cmd.julia
    - match: '`'
      pop: true
    - include: string-escape
    - match: \$
      scope: keyword.operator.julia
      set: string-cmd-interpolation

  string-cmd-interpolation:
    - match: (?<=\))
      set: string-cmd-content
    - include: nested_parens
    - match: '{{symb_id}}+'
      scope: variable.other.julia
      set:
        - match: ''
          set: string-cmd-content

  nested_parens:
    - match: \(
      push:
        - match: \)
          pop: true
        - include: expressions

  nested_squarebrackets:
    - match: \[
      push:
        - match: \]
          pop: true
        - include: expressions
