%YAML 1.2
---
name: Julia
file_extensions: [jl]
first_line_match: ^#!.*\bjulia\s*$
scope: source.julia

# TODO: Clean up look-aheads

variables:
  symb_op_ascii: '[-+*/\\=^:.<>~?&$%|]'
  # The list of unicode symbols allowed as operators is fetched from the Julia parser https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm
  symb_op_unicode: '[≤≥¬←→↔↚↛↠↣↦↮⇎⇏⇒⇔⇴⇶⇷⇸⇹⇺⇻⇼⇽⇾⇿⟵⟶⟷⟷⟹⟺⟻⟼⟽⟾⟿⤀⤁⤂⤃⤄⤅⤆⤇⤌⤍⤎⤏⤐⤑⤔⤕⤖⤗⤘⤝⤞⤟⤠⥄⥅⥆⥇⥈⥊⥋⥎⥐⥒⥓⥖⥗⥚⥛⥞⥟⥢⥤⥦⥧⥨⥩⥪⥫⥬⥭⥰⧴⬱⬰⬲⬳⬴⬵⬶⬷⬸⬹⬺⬻⬼⬽⬾⬿⭀⭁⭂⭃⭄⭇⭈⭉⭊⭋⭌￩￫≡≠≢∈∉∋∌⊆⊈⊂⊄⊊∝∊∍∥∦∷∺∻∽∾≁≃≄≅≆≇≈≉≊≋≌≍≎≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≣≦≧≨≩≪≫≬≭≮≯≰≱≲≳≴≵≶≷≸≹≺≻≼≽≾≿⊀⊁⊃⊅⊇⊉⊋⊏⊐⊑⊒⊜⊩⊬⊮⊰⊱⊲⊳⊴⊵⊶⊷⋍⋐⋑⋕⋖⋗⋘⋙⋚⋛⋜⋝⋞⋟⋠⋡⋢⋣⋤⋥⋦⋧⋨⋩⋪⋫⋬⋭⋲⋳⋴⋵⋶⋷⋸⋹⋺⋻⋼⋽⋾⋿⟈⟉⟒⦷⧀⧁⧡⧣⧤⧥⩦⩧⩪⩫⩬⩭⩮⩯⩰⩱⩲⩳⩴⩵⩶⩷⩸⩹⩺⩻⩼⩽⩾⩿⪀⪁⪂⪃⪄⪅⪆⪇⪈⪉⪊⪋⪌⪍⪎⪏⪐⪑⪒⪓⪔⪕⪖⪗⪘⪙⪚⪛⪜⪝⪞⪟⪠⪡⪢⪣⪤⪥⪦⪧⪨⪩⪪⪫⪬⪭⪮⪯⪰⪱⪲⪳⪴⪵⪶⪷⪸⪹⪺⪻⪼⪽⪾⪿⫀⫁⫂⫃⫄⫅⫆⫇⫈⫉⫊⫋⫌⫍⫎⫏⫐⫑⫒⫓⫔⫕⫖⫗⫘⫙⫷⫸⫹⫺⊢⊣⊕⊖⊞⊟∪∨⊔±∓∔∸≂≏⊎⊻⊽⋎⋓⧺⧻⨈⨢⨣⨤⨥⨦⨧⨨⨩⨪⨫⨬⨭⨮⨹⨺⩁⩂⩅⩊⩌⩏⩐⩒⩔⩖⩗⩛⩝⩡⩢⩣÷⋅∘×∩∧⊗⊘⊙⊚⊛⊠⊡⊓∗∙∤⅋≀⊼⋄⋆⋇⋉⋊⋋⋌⋏⋒⟑⦸⦼⦾⦿⧶⧷⨇⨰⨱⨲⨳⨴⨵⨶⨷⨸⨻⨼⨽⩀⩃⩄⩋⩍⩎⩑⩓⩕⩘⩚⩜⩞⩟⩠⫛⊍▷⨝⟕⟖⟗↑↓⇵⟰⟱⤈⤉⤊⤋⤒⤓⥉⥌⥍⥏⥑⥔⥕⥘⥙⥜⥝⥠⥡⥣⥥⥮⥯￪￬]'
  symb_op: '(?:{{symb_op_ascii}}|{{symb_op_unicode}})'
  long_op: (?:\+=|-=|\*=|/=|//=|\\\\=|^=|÷=|%=|<<=|>>=|>>>=|\|=|&=|:=|=>|$=|\|\||<:|>:|\|>|<\||//|\+\+)
  symb_lang: (?:[(){}\[\],.;:'"@])
  symb_id: (?:[^\s{{symb_lang}}{{symb_op}}]) # general identifier
  boundary: (?<=(?:^|\s|{{symb_lang}}|{{symb_op}})) # alternative to \b
  # Recursively match curly braces. Must be wrapped in a matching group when used, it is best to do this explicitly and not here to avoid confusion
  nested_braces: '{(?>[^{}]+|\g<-1>)*}'

contexts:
  main:
    - include: declarations
    - include: expressions

  expressions:
    - include: comments
    - include: symbols
    - include: type-annotation
    - include: literals
    - include: operators
    - include: strings
    - include: keywords
    - include: macros
    - include: function-call
    - include: variable
    - include: nested_parens

  declarations:
    - include: decl-func
    - include: decl-func-assignment-form
    - include: decl-type
    - include: decl-macro
    - include: decl-typealias

  comments:
    - match: '#='
      push: comment-block
    - match: '#.*'
      scope: comment.line.number-sign.julia

  comment-block:
    - meta_scope: comment.block.number-sign-equals.julia
    - match: '#='
      push: comment-block
    - match: '=#'
      pop: true

  keywords:
    - match: \b(begin|end|function|type|macro|quote|let|local|global|const|abstract|typealias|bitstype|immutable|module|baremodule|using|import|export|importall|in)\b
      scope: keyword.other.julia
    - match: \b(if|else|elseif|for|while|do|try|catch|finally|return|break|continue)\b
      scope: keyword.control.julia

  operators:
    # - Bang is not only an operator symbol, it can also be
    #   part of a function name, thus it is treated separately.
    # - Single quote is not only an operator symbol, it can also start a string.
    #   It is an operator if it is not preceded by space or newline

    # - match: ({{symb_op}}|!|(?<!(?:\s|^))')
    #   It is an operator if it is preceded by
    - match: ({{symb_op}}|!|(?<=(?:{{symb_id}}|[.')\]]))')
      scope: keyword.operator.julia

  function-call:
    - match: '({{symb_id}}+)({{nested_braces}})?(?=\()'
      captures:
        # Julians want all their function highlighted by default.
        # The scope `variable.function` is applied last to give it precedence
        # so that user can override the color in the color theme.
        1: support.function.julia variable.function.julia
        2: support.type.julia

  literals:
    - match: |-
        (?x)
        (?:
          {{boundary}}0b[0-1]+|       # binary
          {{boundary}}0o[0-7]+|       # octal
          {{boundary}}0x[\da-fA-F]+|  # hex
          (
            \B\.\d+|                  # .11
            {{boundary}}\d+(\.\d*)?   # 11.11, 11., 11
          )
          (e[-+]?\d+)?|               # 1e123, 1e+123
          (e[-+]\d+)?                 # e+123
        )
      scope: constant.numeric.julia
    - match: \b(true|false|nothing|NaN|Inf)\b
      scope: constant.language.julia

  type-annotation:
    # Dollar is ok because types can be interpolated.
    # Dot is ok because types can be picked from modules,
    # but no more than one dot, because splat can follow type.
    - match: (::|<:)\s*((?:(?!\.\.)(?:[$.]|{{symb_id}}))+({{nested_braces}})?)
      captures:
        1: keyword.operator.julia
        2: support.type.julia

  decl-func:
    - match: '\bfunction\s+'
      scope: keyword.other.julia
      push:
        - meta_scope: meta.function.julia
        - include: func-name-typeconstructor
        - include: func-name-paren
        - include: func-name-macro
        - include: func-name-standard
        # Anonymous function
        - match: \(
          set: function-parameters
        # Function name on the form "Module.func"
        - match: '([^.{(]+)(\.)'
          captures:
            1: variable.other.julia
            2: keyword.operator.julia

  # Do look-aheads to catch and distinguish function definitions on assignment form from function calls
  decl-func-assignment-form:
    - match: '(?=\((?=[^!])(::([^.\)]+))\)({{nested_braces}})?\([^\(\)]*\)\s*=(?!=))'
      push: func-name-typeconstructor
    - match: '(?=(?=[^!])([^\s{{symb_lang}}]+)({{nested_braces}})?\([^\(\)]*\)\s*=(?!=))'
      push: func-name-standard
    - match: '(?=\((?=[^!])([^\s{{symb_lang}}]+)\)({{nested_braces}})?\([^\(\)]*\)\s*=(?!=))'
      push: func-name-paren

  func-name-standard:
    - match: '([^.{(]+)({{nested_braces}})?(?=\()'
      captures:
        1: entity.name.function.julia
        2: support.type.julia
      set: function-parameters

  func-name-typeconstructor:
    - match: '\((::)([^.\)]+)\)({{nested_braces}})?'
      captures:
        1: keyword.operator.julia
        2: entity.name.function.julia
        3: support.type.julia
      set: function-parameters

  func-name-paren:
    - match: '\(([^.{()]+)\)({{nested_braces}})?\('
      captures:
        1: entity.name.function.julia
        2: support.type.julia
      set: function-parameters

  func-name-macro:
    - match: '(@{{symb_id}}+)(?=\()'
      scope: support.function.julia variable.macro.julia
      pop: true

  function-parameters:
    - meta_content_scope: meta.function.parameters.julia
    - match: \)
      pop: true
    - include: comments
    - match: '='
      scope: keyword.operator.assignment.julia
      set:
        - meta_scope: meta.function.parameters.default-value.julia
        - match: '(?=[,)])'
          set: function-parameters
        - include: expressions
    - include: type-annotation
    - match: \.\.\. # Splat after type
      scope: keyword.operator.julia
    - match: ({{symb_id}}+)(\.\.\.)?
      captures:
        1: variable.parameter.julia
        2: keyword.operator.julia

  decl-macro:
    - match: '\b(macro)\s+([^(]+)\('
      captures:
        1: keyword.other.julia
        2: entity.name.macro.julia
      set: function-parameters

  decl-type:
    - match: \b(type|immutable|abstract)\s+({{symb_id}}+)({{nested_braces}})?
      scope: meta.type.julia
      captures:
        1: keyword.other.julia
        2: entity.name.type.julia
        3: support.type.julia
    - match: \b(bitstype)\s+(\d+)\s+({{symb_id}}+({{nested_braces}})?)
      captures:
        1: keyword.other.julia
        2: constant.numeric.julia
        3: entity.name.type.julia

  decl-typealias:
    - match: \b(typealias)\s+({{symb_id}}+)({{nested_braces}})?\s+({{symb_id}}+({{nested_braces}})?)?
      captures:
        1: keyword.other.julia
        2: entity.name.type.julia
        3: entity.name.type.julia # The nested_braces must be wrapped in a matching group
        4: support.type.julia

  symbols:
    # This is slightly more involved than what one might first expect
    # because, for example, in `:aa` the symbol is `aa` but in `:+a` only `+` is the symbol.
    # Also take some extra steps to not mess up ternary a?b:c syntax.
    - match: |-
        (?x)
        (?<! {{symb_id}}: )   # Not preceded by `a:`
        (?<! {{symb_id}}\s: ) # or `a :` (How to match multiple spaces in lookbehind?)
        (?<! [<)}\].'"]: )    # or other symbol-blocking chars.
        (?<=:)                # Preceeded by colon.
        (                     # The actual symbol can be a
          (\.?{{long_op}})|   # (dotted) multi-character-operator
          (\.?{{symb_op}})|   # (dotted) operator
          {{symb_id}}*        # variable name
        )
      scope: constant.other.symbol.julia

  macros:
    - match: '@{{symb_id}}+\b'
      # Julians want their macros to light up as functions by default
      # The scope `variable.macro` is applied last to give it precedence
      # so that user can override the color in the color theme.
      scope: support.function.julia variable.macro.julia

  variable:
    - match: '{{symb_id}}+({{nested_braces}})?'
      # scope: support.type.julia
      scope: variable.other
    # - match: '{{symb_id}}+'
    #   scope: variable.other.julia

  strings:
    # Regex string: Has special escaping
    - match: '\br"'
      push:
      - meta_scope: string.quoted.other.julia
      - match: (\\"|\\\\)
        scope: constant.character.escape.julia
      - match: '"'
        pop: true
    # Triple double-quoted string
    - match: '"""'
      push:
      - meta_scope: string.quoted.single.julia
      - include: string-escape
      - match: '"""'
        pop: true
    # Double-quoted
    - match: '"'
      push: string-content
    # Prefixed double-quoted
    - match: '{{symb_id}}+"'
      push:
      - meta_scope: string.quoted.other.julia
      - include: string-escape
      - match: '"'
        pop: true
    # Single-quoted string
    - match: "'"
      push:
      - meta_scope: string.quoted.single.julia
      - include: string-escape
      - match: "'"
        pop: true
    # Cmd string
    - match: '`'
      push:
      - meta_scope: string.interpolated.julia
      - match: \\.
        scope: constant.character.escape.julia
      - match: '`'
        pop: true

  string-content:
    - match: '"'
      pop: true
    - meta_scope: string.quoted.double.julia
    - match: \\(\\|[0-3]\d{0,2}|[4-7]\d?|x[a-fA-F0-9]{0,2}|u[a-fA-F0-9]{0,4}|U[a-fA-F0-9]{0,8}|.)
      scope: constant.character.escape.julia
    # - match: (\$)({{symb_id}}+)
    #   captures:
    #     1: keyword.operator
    #     2: variable.other
    - match: \$
      scope: keyword.operator.julia
      set: string-interpolation

  string-interpolation:
    - match: (?<=\))
      set: string-content
    - include: nested_parens
    - match: '{{symb_id}}+'
      scope: variable.other.julia
      set:
        - match: ''
          set: string-content

  string-escape:
    - match: \\(\\|[0-3]\d{0,2}|[4-7]\d?|x[a-fA-F0-9]{0,2}|u[a-fA-F0-9]{0,4}|U[a-fA-F0-9]{0,8}|.)
      scope: constant.character.escape.julia

  # Needed only for string interpolation
  nested_parens:
    - match: \(
      push:
        - match: \)
          pop: true
        - include: expressions
